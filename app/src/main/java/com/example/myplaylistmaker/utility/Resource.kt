package com.example.imdbtraining.utility

sealed class Resource<T>(val data: T? = null, val message: String? = null) {
    class Success<T>(data: T): Resource<T>(data)
    class Error<T>(message: String, data: T? = null): Resource<T>(data, message)
}
//Ключевое слово sealed (изолированный, запечатанный) говорит, что этот класс может иметь ограниченное количество наследников и все они должны быть перечислены внутри этого же класса. Благодаря этому можно использовать класс-обёртку как объект с нужными данными и как индикатор успешности в зависимости от того, наследника какого типа вернёт репозиторий. На примере дальше вы увидите, как это удобно.
//Название Resource выбрано не случайно — так называют подобные обёртки в рамках чистой архитектуры.
//Дженерик-тип такого класса позволяет указать, с данными какого типа мы будем работать в случае успешного выполнения метода.
//В конструкторе класса мы указали, какую информацию он может хранить: объект data нужного нам типа и сообщение о возможной ошибке message.
//Появился наследник класса Success. Репозиторий вернёт экземпляр такого класса в случае, если данные были получены успешно. Объект нужного типа будет передан через конструктор, и к нему можно будет получить доступ по переменной data. Сообщение об ошибке в таком классе всегда будет равно null, потому что в нём не будет нужды.
//Объявился наследник класса Error. Если при получении данных произошла ошибка, то репозиторий вернёт объект этого типа. Сообщение об ошибке обязательно и не может быть равно null. А вот объект data становится опциональным, и в это поле можно что-то передать, если логика приложения предполагает отображение специального набора или ранее сохранённых данных в случае ошибки.